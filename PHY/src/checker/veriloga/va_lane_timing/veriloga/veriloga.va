// Disclaimer:
// THIS FILE IS PROVIDED AS IS AND WITH:
// (A) NO WARRANTY OF ANY KIND, express, implied or statutory, including any implied warranties of merchantability, fitness for a particular purpose and noninfringement, which  Infineon disclaims to the maximum extent permitted by applicable law; and
// (B) NO INDEMNIFICATION FOR INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS.
// (C) LIMITATION OF LIABILITY: IN NO EVENT SHALL INFINEON BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES (INCLUDING LOST PROFITS OR SAVINGS) WHATSOEVER, WHETHER BASED ON CONTRACT, TORT OR ANY OTHER LEGAL THEORY, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// Â© 2020 Infineon Technologies AG. All rights reserved.

// Note:
// The CMOS transistor models used, were freely available models downloaded from: http://ptm.asu.edu.
// The bipolar transistor models are from: The Development of Bipolar Log-Domain Filters in a Standard CMOS Process, G. D. Duerden, G. W. Roberts, M. J. Deen, 2001

// Release:
// 	version 1.0

// VerilogA for phy_local, lane_timing, veriloga
/*
* Description:
* This block has to measure the time delay between 
* the edges of the binary inputs bin_i<3:0>
* and the edges of clk_i.
* Once a reset has been made (simple pulse),
* all time delays will be averaged and the output is
* given to dt_ao<3:0>.
* If rising_edge_i == 1: We measure the rising edges.
* If rising_edge_i == 0: We measure the falling edges.
*/


`include "constants.vams"
`include "disciplines.vams"

module va_lane_timing(dt_0_ao, dt_1_ao, bin_i, clk_i, reset, rising_edge_i);
output dt_0_ao, dt_1_ao;
electrical dt_0_ao, dt_1_ao;
input bin_i;
electrical bin_i;
input clk_i, rising_edge_i;
electrical clk_i, rising_edge_i;
input reset;
electrical reset;


/*
* Parameter
*/
parameter real vhigh = 1.5;
parameter real trf = 30p;

/*
* Variables for Outputs/Inputs
*/
real    dt0   = 0;
real    dt1   = 0;
real    dttotal0 = 0;
integer numAvg0 = 0;
real    dttotal1 = 0;
integer numAvg1 = 0;
real    temp = 0;

/*
* Variables
*/
integer currentEdgeBin = 0;
integer currentEdgeClk = 0;

/*
* Variables for timing
*/
real edgesBin[0:1] = {-1,-1};
real edgesClk[0:1] = {-1,-1};

/*
* Variables for loops
*/
integer i = 0;

/*
* Reset
*/
analog begin
    @(above(V(reset) - vhigh/2)) begin
        edgesBin[0]    = -1;
        edgesBin[1]    = -1;
        edgesClk[0]    = -1;
        edgesClk[1]    = -1;
        dttotal0       = 0;
        numAvg0        = 0;
        dttotal1       = 0;
        numAvg1        = 0;
        dt0            = 0;
        dt1            = 0;
        currentEdgeBin = 0;
        currentEdgeClk = 0;
    end
end

/*
* Evaluate edges
*/
analog begin    
    if (currentEdgeBin>1 && currentEdgeClk>1) begin
        // Two options for the skew
        // we output both because this block cannot know what to expect
        // Option 1: bin first
        // Option 2: clk first

        if (edgesBin[0] < edgesClk[0]) begin
            // bin comes first
            temp           = edgesClk[0] - edgesBin[0];
            dttotal0       = dttotal0 + temp;
            numAvg0        = numAvg0 + 1;
            dt0            = dttotal0/numAvg0;

            temp           = edgesBin[1] - edgesClk[0];
            dttotal1       = dttotal1 + temp;
            numAvg1        = numAvg1 + 1;
            dt1            = dttotal1/numAvg1;
        end else begin
            // clk comes first
            temp           = edgesBin[0] - edgesClk[0];
            dttotal0       = dttotal0 + temp;
            numAvg0        = numAvg0 + 1;
            dt0            = dttotal0/numAvg0;

            temp           = edgesClk[1] - edgesBin[0];
            dttotal1       = dttotal1 + temp;
            numAvg1        = numAvg1 + 1;
            dt1            = dttotal1/numAvg1;
        end

        edgesBin[0]    = edgesBin[1];
        edgesBin[1]    = -1;
        edgesClk[0]    = edgesClk[1];
        edgesClk[1]    = -1;
        currentEdgeBin = 1;
        currentEdgeClk = 1;
    end
end


/*
* Measure bin edges
*/
analog begin    

    @(cross(V(bin_i) - 0, +1)) begin
        if (V(reset)<vhigh/2 && V(rising_edge_i) > vhigh/2) begin
            if (currentEdgeBin>1) begin                 
                $strobe("[ERROR] Edges are messed up! Reset measurement (lane_timing.va)");
                edgesBin[0]    = -1;
                edgesBin[1]    = -1;
                edgesClk[0]    = -1;
                edgesClk[1]    = -1;
                dttotal0       = 0;
                numAvg0        = 0;
                dttotal1       = 0;
                numAvg1        = 0;
                dt0            = 0;
                dt1            = 0;
                currentEdgeBin = 0;
                currentEdgeClk = 0;
            end else begin
                edgesBin[currentEdgeBin] = $abstime;
                currentEdgeBin = currentEdgeBin + 1;
            end
        end
    end

    @(cross(V(bin_i) - 0, -1)) begin
        if (V(reset)<vhigh/2 && V(rising_edge_i) < vhigh/2) begin
            if (currentEdgeBin>1) begin                 
                $strobe("[ERROR] Edges are messed up! Reset measurement (lane_timing.va)");
                edgesBin[0]    = -1;
                edgesBin[1]    = -1;
                edgesClk[0]    = -1;
                edgesClk[1]    = -1;
                dttotal0       = 0;
                numAvg0        = 0;
                dttotal1       = 0;
                numAvg1        = 0;
                dt0            = 0;
                dt1            = 0;
                currentEdgeBin = 0;
                currentEdgeClk = 0;
            end else begin
                edgesBin[currentEdgeBin] = $abstime;
                currentEdgeBin = currentEdgeBin + 1;
            end
        end
    end
end


/*
* Measure clk edge
*/
analog begin    
    // Rising edge
    @(cross(V(clk_i) - 0, +1)) begin

        if (V(reset)<vhigh/2 && V(rising_edge_i) > vhigh/2) begin
            if (currentEdgeClk>1) begin                 
                $strobe("[ERROR] Edges are messed up! Reset measurement (lane_timing.va)");
                edgesBin[0]    = -1;
                edgesBin[1]    = -1;
                edgesClk[0]    = -1;
                edgesClk[1]    = -1;
                dttotal0       = 0;
                numAvg0        = 0;
                dttotal1       = 0;
                numAvg1        = 0;
                dt0            = 0;
                dt1            = 0;
                currentEdgeBin = 0;
                currentEdgeClk = 0;
            end else begin
                edgesClk[currentEdgeClk] = $abstime;
                currentEdgeClk = currentEdgeClk + 1;
            end
        end
    end
    
    // Falling edge
    @(cross(V(clk_i) - 0, -1)) begin

        if (V(reset)<vhigh/2 && V(rising_edge_i) < vhigh/2) begin
            if (currentEdgeClk>1) begin                 
                $strobe("[ERROR] Edges are messed up! Reset measurement (lane_timing.va)");
                edgesBin[0]    = -1;
                edgesBin[1]    = -1;
                edgesClk[0]    = -1;
                edgesClk[1]    = -1;
                dttotal0       = 0;
                numAvg0        = 0;
                dttotal1       = 0;
                numAvg1        = 0;
                dt0            = 0;
                dt1            = 0;
                currentEdgeBin = 0;
                currentEdgeClk = 0;
            end else begin
                edgesClk[currentEdgeClk] = $abstime;
                currentEdgeClk = currentEdgeClk + 1;
            end
        end
    end
end

/*
* Input/Output interaction
*/
analog begin
       
    // Set outputs
    V(dt_0_ao   ) <+ transition(dt0*1e9, 0, trf,trf); // convert to ns
    V(dt_1_ao   ) <+ transition(dt1*1e9, 0, trf,trf); // convert to ns

end



endmodule
