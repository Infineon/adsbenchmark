// Disclaimer:
// THIS FILE IS PROVIDED AS IS AND WITH:
// (A) NO WARRANTY OF ANY KIND, express, implied or statutory, including any implied warranties of merchantability, fitness for a particular purpose and noninfringement, which  Infineon disclaims to the maximum extent permitted by applicable law; and
// (B) NO INDEMNIFICATION FOR INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS.
// (C) LIMITATION OF LIABILITY: IN NO EVENT SHALL INFINEON BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES (INCLUDING LOST PROFITS OR SAVINGS) WHATSOEVER, WHETHER BASED ON CONTRACT, TORT OR ANY OTHER LEGAL THEORY, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// Â© 2020 Infineon Technologies AG. All rights reserved.

// Note:
// The CMOS transistor models used, were freely available models downloaded from: http://ptm.asu.edu.
// The bipolar transistor models are from: The Development of Bipolar Log-Domain Filters in a Standard CMOS Process, G. D. Duerden, G. W. Roberts, M. J. Deen, 2001

// Release:
// 	version 1.0

// VerilogA for phy_local, lane_voltage_level_checker, veriloga

`include "constants.vams"
`include "disciplines.vams"


/*
*
*/
module va_lane_voltage_level_checker(sample_i, vcmtx_ao, vod_ao,
dVcmtx_10_ao, dvod_ao, vohhs_ao, volhs_ao, DN_ai, DP_ai);

output vcmtx_ao;
electrical vcmtx_ao;
output vod_ao;
electrical vod_ao;
output dVcmtx_10_ao;
electrical dVcmtx_10_ao;
output dvod_ao;
electrical dvod_ao;
output vohhs_ao;
electrical vohhs_ao;
output volhs_ao;
electrical volhs_ao;
input DN_ai;
electrical DN_ai;
input DP_ai;
electrical DP_ai;
input sample_i;
electrical sample_i;


/*
* Parameter
*/
parameter real vhigh = 1.5;
parameter real trf = 30p;


/*
* Variables for the outputs
*/
real vcmtx_s = 0;
real dVcmtx_10_s = 0;
real vod_s = 0;
real dVod_s = 0;
real vohhs_s = 0;
real volhs_s = 0;


/*
* Variables
*/
real vcmtx0 = 0;
real vcmtx1 = 0;
real vod0   = 0;
real vod1   = 0;


/*
* Update variables
*/
analog begin

    @( cross(V(sample_i), 0) ) begin

        vod_s   = V(DP_ai) - V(DN_ai);
        vcmtx_s = (V(DP_ai) + V(DN_ai))/2;

        if (V(DP_ai) < V(DN_ai)) begin
            vohhs_s = V(DN_ai);
            volhs_s = V(DP_ai);

            vod0    =  abs(vod_s);
            vcmtx0  = vcmtx_s;
        end else begin
            vohhs_s = V(DP_ai);
            volhs_s = V(DN_ai);

            vod1    =  abs(vod_s);
            vcmtx1  = vcmtx_s;
        end

        dVcmtx_10_s = (vcmtx1 - vcmtx0)/2;
        dVod_s = vod1 - vod0;
    end

end



/*
* Set outputs
*/
analog begin
    V(vcmtx_ao     ) <+ transition(vcmtx_s,     0, trf,trf);
    V(dVcmtx_10_ao ) <+ transition(dVcmtx_10_s, 0, trf,trf);
    V(dvod_ao      ) <+ transition(dVod_s,      0, trf,trf);
    V(vohhs_ao     ) <+ transition(vohhs_s,     0, trf,trf);
    V(volhs_ao     ) <+ transition(volhs_s,     0, trf,trf);
    V(vod_ao       ) <+ transition(vod_s,       0, trf,trf);
end

endmodule
